Enhance the accuracy, reactivity, and interactivity of the program flowchart to ensure it always reflects the current logic of visual code blocks.

Context: The app currently allows users to build C programs using drag-and-drop visual blocks. These blocks are parsed and run correctly, but the flowchart displayed does not accurately represent the actual logic flow ‚Äî especially after changes to blocks. The flowchart often shows outdated or incorrect paths (e.g., showing the "else" branch when the code clearly executes the "if" branch).

‚úÖ Key Improvements to Implement:
Dynamic Regeneration of Flowchart:

Automatically rebuild the flowchart every time code blocks are added, removed, reordered, or modified.

Do not rely on static or cached layouts ‚Äî instead, parse the current block structure in real-time.

AST-Based Logic Syncing:

Build a lightweight AST (Abstract Syntax Tree) from the ordered visual blocks.

Parse this structure into a control flow graph (CFG) that accurately reflects conditionals, loops, and block nesting.

Convert this graph into visual nodes/edges for the flowchart.

Flowchart Rendering Logic:

Each node should represent a logical step (e.g., declaration, condition, function call).

Branching nodes (like if/else) should have clearly labeled edges: Yes / No.

Loop structures (like while, for) should have feedback arrows to earlier steps.

Sync with Visual Blocks:

Highlight a flowchart node when a user clicks the corresponding code block.

When hovering a node in the flowchart, highlight the associated code block.

Live Execution Path Highlighting (Optional but Powerful):

After the user hits Run, dynamically highlight the executed path in the flowchart (e.g., green for executed nodes, gray for skipped paths).

Clear Flowchart Before Rebuilding:

Ensure previous flowcharts are destroyed or cleared to avoid overlapping nodes or duplicated paths.

Fallback/Error State Handling:

If the logic is incomplete (e.g., unclosed braces or unmatched blocks), the flowchart should either:

Display a warning like ‚ÄúIncomplete Program: Cannot visualize flow.‚Äù

Or show a partial flowchart with a red warning indicator.

üéØ Expected Outcome:
The flowchart perfectly mirrors the logic built through code blocks.

Every program update reflects immediately in the flowchart.

Users gain a true visual understanding of control flow based on their own logic.

Execution and flowchart become fully aligned ‚Äî enhancing both learning and debugging.

